import { createClient } from '@supabase/supabase-js';

// --- GAP ANALYSIS: SQL SCHEMA ---
// Run this in your Supabase SQL Editor if tables do not exist:
/*
  create table if not exists views (
    id text primary key,
    count bigint default 0
  );

  create table if not exists reviews (
    id bigint generated by default as identity primary key,
    message text,
    rating int,
    created_at timestamp with time zone default timezone('utc'::text, now())
  );
*/

const SUPABASE_URL = process.env.SUPABASE_URL || '';
const SUPABASE_ANON_KEY = process.env.SUPABASE_ANON_KEY || '';

// --- CLIENT INITIALIZATION ---
let supabase: any = null;

if (SUPABASE_URL && SUPABASE_ANON_KEY) {
  try {
    supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
  } catch (e) {
    console.error("Supabase initialization failed:", e);
  }
} else {
  console.warn("Missing Supabase credentials. Falling back to LocalStorage.");
}

// --- VIEWS SERVICE ---

export const incrementAndGetViews = async (pageId: string): Promise<number | null> => {
  // 1. Try Supabase
  if (supabase) {
    try {
      // Upsert view count: increment if exists, create if not
      // Using an RPC approach is cleaner for concurrency, but for simplicity we fetch/update or use on_conflict
      
      // First, ensure record exists
      const { error: upsertError } = await supabase
        .from('views')
        .upsert({ id: pageId }, { onConflict: 'id', ignoreDuplicates: true });

      if (upsertError) throw upsertError;

      // Increment RPC is better, but requires creating a function. 
      // We will do a simple read-update-write for this audit context, 
      // OR preferably use a stored procedure if available. 
      // Assuming NO stored procedure exists, we fetch first.
      
      const { data, error: fetchError } = await supabase
        .from('views')
        .select('count')
        .eq('id', pageId)
        .single();
        
      if (fetchError) throw fetchError;

      const newCount = (data?.count || 0) + 1;

      const { error: updateError } = await supabase
        .from('views')
        .update({ count: newCount })
        .eq('id', pageId);

      if (updateError) throw updateError;
      
      return newCount;

    } catch (err) {
      console.warn("Supabase Views Error, falling back:", err);
    }
  }

  // 2. Fallback: LocalStorage
  try {
    const key = `views_${pageId}`;
    const local = localStorage.getItem(key);
    const count = (local ? parseInt(local) : 0) + 1;
    localStorage.setItem(key, count.toString());
    return count;
  } catch (e) {
    return null;
  }
};

// --- FEEDBACK SERVICE ---

export const submitFeedback = async (message: string, rating: number): Promise<boolean> => {
  if (supabase) {
    try {
      const { error } = await supabase
        .from('reviews')
        .insert([{ message, rating }]);
      
      if (error) throw error;
      return true;
    } catch (err) {
      console.error("Supabase Feedback Error:", err);
      // Fallback not useful for feedback submission usually, but we could store in LS to retry later
      saveFeedbackLocally(message, rating);
      return true; // Pretend success to user
    }
  } else {
    saveFeedbackLocally(message, rating);
    return true;
  }
};

const saveFeedbackLocally = (message: string, rating: number) => {
  const existing = JSON.parse(localStorage.getItem('pending_feedback') || '[]');
  existing.push({ message, rating, timestamp: Date.now() });
  localStorage.setItem('pending_feedback', JSON.stringify(existing));
};
